<!DOCTYPE html>
<html>
	<head>
	<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
	<meta charset="utf-8">
	<title>Bike The Beach Route Builder</title>
	<style>
	html, body, #map
	{
		height: 100%;
		margin: 0px;
		padding: 0px
	}

	#panel
	{
		position: absolute;
		top: 5px;
		left: 50%;
		margin-left: -180px;
		z-index: 5;
		background-color: #fff;
		padding: 5px;
		border: 1px solid #999;
	}

	#bar
	{
		width: 240px;
		background-color: rgba(255, 255, 255, 0.75);
		margin: 8px;
		padding: 4px;
		border-radius: 4px;
	}

	#autoc
	{
		width: 100%;
		box-sizing: border-box;
	}
	</style>

	<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<script src="https://maps.googleapis.com/maps/api/js?libraries=drawing,places"></script>
	<script>
	var apiKey = 'AIzaSyBUyIV-JfLai3CEzPCOIRmWrfZU8-c4hm4';

	var map;					// Stores Google Map object
	var snappedPolyline;		// Stores Polyline object
	var markers = [];			// Array of Google Marker Objects

	MAX_VERTS_PER_PAGE = 100;

	function initialize()
	{
		var mapOptions =
		{
			zoom: 17,
			center: {lat: 41.143353, lng: -73.236580},
			streetViewControl : false,
			mapTypeControl : false,
			styles : [{featureType : "poi", elementType : "labels", stylers : [{visibility : "off"}]}]
		};
		map = new google.maps.Map(document.getElementById('map'), mapOptions);
		
		map.addListener('click', addMarker);
		snappedPolyline = new google.maps.Polyline({strokeColor: 'blue', strokeWeight: 5, map : map, strokeOpacity : 0.5});
		snappedPolyline.addListener('click', insertMarker);
		
		
	}

	// Call Snap To Road API
	function runSnapToRoad(startIndex, coords)
	{
		var pathValues = new Array();

		// Load next Vertices
		var tmp = markers.slice(startIndex, startIndex + MAX_VERTS_PER_PAGE);
		for (var i = 0; i < tmp.length; i ++)
		{
			pathValues.push(markers[i + startIndex].position.lat() + "," + markers[i + startIndex].position.lng());
		}

		if(pathValues.length > 0)
		{
			$.get('https://roads.googleapis.com/v1/snapToRoads',
			{
				interpolate: true,
				key: apiKey,
				path: pathValues.join('|')
			},
			function(data)
			{
				for (var i = 0; i < data.snappedPoints.length; i ++)
				{
					var latlng = new google.maps.LatLng(
						data.snappedPoints[i].location.latitude,
						data.snappedPoints[i].location.longitude
					);
					
					if(data.snappedPoints[i].originalIndex)
					{
						markers[data.snappedPoints[i].originalIndex + startIndex].setPosition(latlng);
					}
					coords.push(latlng);
				}

				runSnapToRoad(startIndex + MAX_VERTS_PER_PAGE, coords);
			});
		}
		else
		{
			snappedPolyline.setPath(coords);
			console.log(markers.length);
		}
	}

	/*
	function runSnapToRoad(startPage)
	{
		// Clear polylines first
		for(var i = 0; i < markers.length; i ++)
		{
			if(markers[i].polyline)
				markers[i].polyline.setMap(null);
		}

		if(startPage == 0)
		{
			polylineCoords = [];
			pages = Math.ceil(markers.length / MAX_VERTS_PER_PAGE);
		}

		var pathValues = [];
		var endIndex = (startPage + 1) * MAX_VERTS_PER_PAGE;

		// Load next Vertices
		for (var i  in markers.slice(startPage * MAX_VERTS_PER_PAGE, endIndex))
		{
			pathValues.push(markers[i].position.lat() + "," + markers[i].position.lng());
		}

		console.log("Calling Google API : " + pathValues.join('|'));
		// Call API
		$.get('https://roads.googleapis.com/v1/snapToRoads',
		{
			interpolate: true,
			key: apiKey,
			path: pathValues.join('|')
		},
		function(data)
		{
			processSnapToRoadResponse(data, startPage * MAX_VERTS_PER_PAGE);
			if(startPage < pages)
			{
				runSnapToRoad(++startPage);
			}
			else
			{
				console.log(endIndex);
				console.log(markers.length);
			}
		});
	}*/

	// Store snapped polyline returned by the snap-to-road method.
	function processSnapToRoadResponse(data, startIndex)
	{
		var polylineCoords = [];
		for (var i = startIndex; i < data.snappedPoints.length; i ++)
		{
			var latlng = new google.maps.LatLng(
			data.snappedPoints[i].location.latitude,
			data.snappedPoints[i].location.longitude);
			
			if(data.snappedPoints[i].originalIndex)
			{
				markers[data.snappedPoints[i].originalIndex].setPosition(latlng);
			}
			
			polylineCoords.push(latlng);
		}
		snappedPolyline.setPath(polylineCoords);
	}

	// Drag Marker
	function dragMarker(event)
	{
		runSnapToRoad(0, []);
	}

	// Remove Marker
	function removeMarker(event)
	{
		var idx = markers.indexOf(this);
		var removed = markers.splice(idx, 1);
		removed[0].setMap(null);
		runSnapToRoad(0, []);
	}

	// Add marker
	function addMarker(event)
	{
		var markerTmp = new google.maps.Marker({position : event.latLng, map : map, draggable : true});

		markerTmp.addListener('dragend', dragMarker);
		markerTmp.addListener('click', removeMarker);

		markers.push(markerTmp);

		runSnapToRoad(0, []);
	}
	
	// Add Midpoint Marker
	function insertMarker(event)
	{
		var distances = [];
		// Convenience Declaration
		var dist = google.maps.geometry.spherical.computeDistanceBetween;
		for(var i = 0; i < markers.length - 1; i ++)
		{
			distances.push(
			{
				index : i,
				value : dist(event.latLng, markers[i].getPosition()) + dist(event.latLng, markers[i + 1].getPosition())
			});
		}
		// Determine where in the array to place the new marker
		distances.sort(function(a, b){return a.value - b.value});
		
		// Add the new marker
		var markerTmp = new google.maps.Marker({position : event.latLng, map : map, draggable : true});
		markerTmp.addListener('dragend', dragMarker);
		markerTmp.addListener('click', removeMarker);
		console.log(distances[0].index + 1);
		markers.splice(distances[0].index + 1, 0, markerTmp);
		runSnapToRoad(0, []);
	}
	
	$(window).load(initialize);
	</script>
	</head>

	<body>
	<div id="map"></div>
	<div id="bar">
	<p class="auto"><input type="text" id="autoc"/></p>
	<p><a id="clear" href="#">Click here</a> to clear map.</p>
	</div>
	</body>
</html>